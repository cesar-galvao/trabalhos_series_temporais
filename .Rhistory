decomp_mstl %>% autoplot(main = "Decomposição MSTL com período anual simples") + labs(x = "Ano") + theme_bw()
ndiffs(serie_ms)
serie_ms %>% diff() %>% nsdiffs()
serie_ms_diff <- serie_ms %>% diff() %>% diff(lag = 12)
# Graficos de Autocorrelacao
par(mfrow=c(1,3))
plot(serie_ms_diff, main="Série com diferenças",ylab="")
acf(serie_ms_diff, lag=12*6, main="ACF")
pacf(serie_ms_diff, lag=12*6, main="PACF")
melhor_AICc <- Inf
for(p in 0:2){
for(q in 0:2){
for(P in 0:2){
for(Q in 0:2){
#cat("p =",p,", q =",q,", P =",P,", Q =",Q,"\n")
tryCatch({fit <- Arima(serie_ms, order=c(p,1,q), seasonal=c(P,1,Q))}, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
if(fit$aicc <= melhor_AICc){
melhor_AICc <- fit$aicc
#cat("p =",p,", q =",q,", P =",P,", Q =",Q,", AICc =",fit$aicc,"\n")}
}
}
}
}
melhor_AICc <- Inf
for(p in 0:2){
for(q in 0:2){
for(P in 0:2){
for(Q in 0:2){
#cat("p =",p,", q =",q,", P =",P,", Q =",Q,"\n")
tryCatch({fit <- Arima(serie_ms, order=c(p,1,q), seasonal=c(P,1,Q))}, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
if(fit$aicc <= melhor_AICc){
melhor_AICc <- fit$aicc
#cat("p =",p,", q =",q,", P =",P,", Q =",Q,", AICc =",fit$aicc,"\n")
}
}
}
}
}
melhor_AICc <- Inf
for(p in 0:2){
for(q in 0:2){
for(P in 0:2){
for(Q in 0:2){
#cat("p =",p,", q =",q,", P =",P,", Q =",Q,"\n")
tryCatch({fit <- Arima(serie_ms, order=c(p,1,q), seasonal=c(P,1,Q))})
if(fit$aicc <= melhor_AICc){
melhor_AICc <- fit$aicc
#cat("p =",p,", q =",q,", P =",P,", Q =",Q,", AICc =",fit$aicc,"\n")
}
}
}
}
}
melhor_AICc <- Inf
for(p in 0:2){
for(q in 0:2){
for(P in 0:2){
for(Q in 0:2){
#cat("p =",p,", q =",q,", P =",P,", Q =",Q,"\n")
tryCatch({fit <- Arima(serie_ms, order=c(p,1,q), seasonal=c(P,1,Q))}, error=function(e){cat("",conditionMessage(e), "\n")})
if(fit$aicc <= melhor_AICc){
melhor_AICc <- fit$aicc
#cat("p =",p,", q =",q,", P =",P,", Q =",Q,", AICc =",fit$aicc,"\n")
}
}
}
}
}
if(!("pacman" %in% installed.packages())){install.packages("pacman")}
pacman::p_load(Mcomp, tidyverse, forecast, fpp2, xts, tseries, tidymodels, kableExtra)
# #funcao not in para facilitar filtragens
# `%notin%` <- Negate(`%in%`)
# T2 -> 2169 ou 2183
data(M3) #carrega os dados
id <- 2183 #série temporal escolhida
serie <- M3[[id]]
dados <- serie$x
plot(serie, main = "Série Temporal M3-2183")
serie_ms <- forecast::msts(dados, seasonal.periods = c(12))
# media dos resíduos é em torno de 5. Considerando a magnitude dos dados que temos usando summary(dados), está próximo de zero o suficiente
#tentei períodos secundários, porém o melhor ajuste é com apenas um ciclo anual. Só é possível dois ciclos secundários completos para análise até quadrienal, mas até aí todos apresentam resíduos inadequados.
decomp_mstl <- mstl(serie_ms, lambda = NULL, t.window = 9)
#ajustar com lambda = "auto" até agora não parece fazer qualquer diferença
decomp_mstl %>% autoplot(main = "Decomposição MSTL com período anual simples") + labs(x = "Ano") + theme_bw()
# diferenciacoes comuns
# ndiffs(serie_ms)
#diferenciacoes sazonais
# serie_ms %>% diff() %>% nsdiffs()
serie_ms_diff <- serie_ms %>% diff() %>% diff(lag = 12)
# Inicializacao dos resíduos
fit <- Arima(dados, order=c(2,1,2), seasonal=c(0,1,2)) #modelo selecionado em outro estágio da análise
E <- window(fit$residuals, start=c(1984,1))
kpss.test(E) %>%
tidy()%>%
select(method, statistic, `p.value`) %>%
knitr::kable(
format = "latex",
align = c("lccc"),
booktabs = TRUE,
longtable = TRUE,
linesep = "",
escape = FALSE,
digits = 2,
col.names = c("", "Estatística", "p-valor")
) %>%
kableExtra::kable_styling(
position = "center",
latex_options = c("striped", "repeat_header"),
stripe_color = "gray!15")
# Graficos de Autocorrelacao
par(mfrow=c(1,3))
plot(serie_ms_diff, main="Série com diferenças",ylab="")
acf(serie_ms_diff, lag=12*6, main="ACF")
pacf(serie_ms_diff, lag=12*6, main="PACF")
melhor_AICc <- Inf
for(p in 0:2){
for(q in 0:2){
for(P in 0:2){
for(Q in 0:2){
#cat("p =",p,", q =",q,", P =",P,", Q =",Q,"\n")
tryCatch({fit <- Arima(serie_ms, order=c(p,1,q), seasonal=c(P,1,Q))}, error=function(e){cat("",conditionMessage(e), "\n")})
if(fit$aicc <= melhor_AICc){
melhor_AICc <- fit$aicc
#cat("p =",p,", q =",q,", P =",P,", Q =",Q,", AICc =",fit$aicc,"\n")
}
}
}
}
}
#melhor_AICc
# teste com auto.arima para verificar
#auto.arima(serie_ms)
# Analise de residuos
par(mfrow=c(1,3))
plot(E, main="Resíduos",ylab="")
qqnorm(E)
qqline(E)
acf(E,lag.max=12*6,main="ACF")
#Testes
box <- Box.test(E,lag=15,type="Ljung-Box") %>% tidy() %>% select(method, everything()) %>% mutate(parameter = as.character(parameter)) #independencia
shap <- shapiro.test(E) %>% tidy() %>% mutate(parameter = "") %>% select(method, everything())  #normalidade
bind_rows(box, shap) %>%
knitr::kable(
format = "latex",
align = c("lccc"),
booktabs = TRUE,
longtable = TRUE,
linesep = "",
escape = FALSE,
digits = 2,
col.names = c("", "Estatística", "p-valor", "Lag")
) %>%
kableExtra::kable_styling(
position = "center",
latex_options = c("striped", "repeat_header"),
stripe_color = "gray!15")
rm(box, shap)
# Transformacao de Box-Cox
autolambda <- BoxCox.lambda(dados)
dadosbc <- BoxCox(dados, lambda=autolambda)
par(mfrow=c(1,2))
plot(dados, main='Série original',ylab='')
plot(dadosbc, main='Série transformada',ylab='')
# Diferencas (BC)
# ndiffs(dadosbc)
# dadosbc %>% diff() %>% nsdiffs()
dadosbcdiff <- dadosbc %>% diff() %>% diff(lag = 12)
fit2 <- Arima(dadosbc, order=c(2,1,2), seasonal=c(0,1,2))# modelo ajustado em etapa posterior da análise
E2 <- window(fit2$residuals, start=c(1984,1))
kpss.test(E2) %>%
tidy()%>%
select(method, statistic, `p.value`) %>%
knitr::kable(
format = "latex",
align = c("lccc"),
booktabs = TRUE,
longtable = TRUE,
linesep = "",
escape = FALSE,
digits = 2,
col.names = c("", "Estatística", "p-valor")
) %>%
kableExtra::kable_styling(
position = "center",
latex_options = c("striped", "repeat_header"),
stripe_color = "gray!15")
# Graficos de Autocorrelacao (BC)
par(mfrow=c(1,3))
plot(dadosbcdiff, main="Série (boxcox) com dif.",ylab="")
acf(E2, lag=12*6, main="ACF")
pacf(E2, lag=12*6, main="PACF")
# Criterio de Akaike (BC)
melhor_AICc <- Inf
for(p in 0:2){
for(q in 0:2){
for(P in 0:2){
for(Q in 0:2){
#cat("p =",p,", q =",q,", P =",P,", Q =",Q,"\n")
tryCatch({fit <- Arima(dadosbc, order=c(p,1,q), seasonal=c(P,1,Q))}, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
if(fit$aicc <= melhor_AICc){
melhor_AICc <- fit$aicc
#cat("p =",p,", q =",q,", P =",P,", Q =",Q,", AICc =",fit$aicc,"\n")}
}
}
}
}
}
# melhor_AICc
# auto.arima(serie_ms)
# Inicializacao
# Analise de residuos
par(mfrow=c(1,3))
plot(E2, main="Resíduos (boxcox)",ylab="")
qqnorm(E2)
qqline(E2)
acf(E,lag.max=12*6,main="ACF")
#Testes
box <- Box.test(E2,lag=15,type="Ljung-Box") %>% tidy() %>% select(method, everything()) %>% mutate(parameter = as.character(parameter)) #independencia
shap <- shapiro.test(E2) %>% tidy() %>% mutate(parameter = "") %>% select(method, everything())  #normalidade
bind_rows(box, shap) %>%
knitr::kable(
format = "latex",
align = c("lccc"),
booktabs = TRUE,
longtable = TRUE,
linesep = "",
escape = FALSE,
digits = 2,
col.names = c("", "Estatística", "p-valor", "Lag")
) %>%
kableExtra::kable_styling(
position = "center",
latex_options = c("striped", "repeat_header"),
stripe_color = "gray!15")
rm(box, shap)
# monta as combinações possíveis de modelo ets
model <- expand_grid(v1 = c("A", "M", "N"), v2 = c("A", "M", "N"), v3 = c("A", "M", "N")) %>%
mutate(modelo = str_c(v1,v2,v3)) %>%
select(modelo) %>%
unique() %>%
expand_grid(., damp = c(TRUE, FALSE))
# N, A, M, + damped
#funcao pra montar indicadores do modelo
criterios <- function(modelo, damp) {
ETS <- ets(dados, model = modelo, damped = damp)
#usamos o objeto dados como um padrao
tabela <- tibble(
nome = modelo,
sigla = str_c("ETS(", str_c(substr(modelo,1,1),  substr(modelo,2,2), substr(modelo,3,3), sep = ","), ")"),
damped = damp,
AIC = ETS$aic,
AICc = ETS$aicc,
BIC = ETS$bic)
return(tabela)
}
#selecionando modelos permitidos pela funcao ets
# for(i in 1:length(model$modelo)){
#   print(i)
#   print(try({ets(dados, model = model$modelo[i], damped = model$damp[i])}, silent = TRUE))
# }
selecionados <- c(1, 2, 5, 6, 14, 18:24, 27:30, 32, 34, 36)
model_select <- model[selecionados,]
tabela_modelos_ETS <- map2_df(model_select$modelo, model_select$damp, criterios) %>%
arrange(AIC) %>%
mutate(modelo = case_when(
damped == TRUE ~ str_replace(sigla, ",A", ",Ad"),
.default = sigla
))
tabela_modelos_ETS %>%
select("Modelo"= modelo, AIC:BIC)%>%
head(6) %>%
knitr::kable(
format = "latex",
align = c("lccc"),
booktabs = TRUE,
longtable = TRUE,
linesep = "",
escape = FALSE,
digits = 2
) %>%
kableExtra::kable_styling(
position = "center",
latex_options = c("striped", "repeat_header"),
stripe_color = "gray!15")
tabela_modelos_ETS %>%
select("Modelo"= modelo, AIC:BIC)%>%
head(6)
?ets
# Definindo as funções de previsão
# Arima
f_arima <- function(y, h){
fit = Arima(y, order=c(2,1,2), seasonal=c(0,1,2))
forecast(fit, h)
}
# Arima com transformação
f_arima_transf <- function(y, h){
fit = Arima(y, order=c(2,1,2), seasonal=c(0,1,2), lambda = 0.712)
forecast(fit, h)
}
# ETS
f_ets <- function(y, h){
fit = ets(y, model="MAM", damped = TRUE)
forecast(fit, h)
}
# ETS com transformação
f_ets_transf <- function(y, h){
fit = ets(y, model="MAM", lambda = 0.712, damped = TRUE)
forecast(fit, h)
}
dados
# Tamanho da série
n <- length(dados)
n
CV_arima <- tsCV(y = dados, forecastfunction = f_arima, h = 5, initial = n-14)
CV_arima
dados
CV_arima_transf <- tsCV(y = dados, forecastfunction = f_arima_transf,
h = 5, initial = n-14)
CV_ets <- tsCV(y = dados, forecastfunction = f_ets, h = 5, initial = n-14)
CV_ets_transf <- tsCV(y = dados, forecastfunction = f_ets_transf,
h = 5, initial = n-14)
CV_arima_transf
n
n-14
?tsCV
# Arima
f_arima <- function(y, h){
fit = Arima(y, order=c(2,1,2), seasonal=c(0,1,2))
return(forecast(fit, h))
}
CV_arima <- tsCV(y = dados, forecastfunction = f_arima, h = 5, initial = n-14)
CV_arima
dados
CV_arima %>% abs() %>% colMeans(na.rm=T)
kpss.test(E)
kpss.test(E) %>%
tidy()
kpss.test(E) %>%
tidy()%>%
select(method, statistic, `p.value`)
# avalia valor de lambda da transformacao boxcox
lambda <- dados %>% BoxCox.lambda()
dados_box <- dados %>% BoxCox(lambda)
# visualização e decomp da ETS com transformação
plot(dados_box,main= parse(text = paste0('"Série com transformação Box-Cox  "', '~ lambda == ', round(lambda, 3))))
MAE_arima <- CV_arima %>% abs() %>% colMeans(na.rm=T)
MAE_arima_transf <-  CV_arima_transf %>% abs() %>% colMeans(na.rm=T)
MAE_arima_transf <-  CV_arima_transf %>% abs() %>% colMeans(na.rm=T)
MAE_ets <-  CV_ets %>% abs() %>% colMeans(na.rm=T)
MAE_ets_transf <-  CV_ets_transf %>% abs() %>% colMeans(na.rm=T)
MAE_arima
MAE_arima_transf
MAE_ets
MAE_ets_transf
tab
tab <- cbind(as.numeric(MAE_arima), as.numeric(MAE_ets))
tab <- cbind(as.numeric(MAE_arima), as.numeric(MAE_ets))
tab_transf <- cbind(MAE_arima_transf, MAE_ets_transf)
tab_erros <-  data.frame(MAE_arima, MAE_ets, MAE_arima_transf, MAE_ets_transf)
tab_erros <-  data.frame(MAE_arima, MAE_ets, MAE_arima_transf, MAE_ets_transf)
colnames(tab_erros) <- c('ARIMA', 'ETS',
'ARIMA Transformada', 'ETS Transformada')
tab
tab_transf
MAE_ets_transf
MAE_ets
CV_ets_transf <- tsCV(y = dados, forecastfunction = f_ets_transf,
h = 5, initial = n-14)
CV_ets_transf
CV_ets
# ETS com transformação
f_ets_transf <- function(y, h){
fit = ets(y, model="MAM", lambda = 0.712, damped = TRUE)
forecast(fit, h)
}
CV_ets_transf <- tsCV(y = dados, forecastfunction = f_ets_transf,
h = 5, initial = n-14)
CV_ets_transf
knitr::kable(tab_erros)
MAE_ets
plot.ts(tab_erros, plot.type='s',col=1:4,lwd=2,xlab="h",ylab="MAE")
legend(x=1,y=0.44, legend=c("ARIMA", "ETS", "ARIMA Transformada", "ETS Transformada"), col=1:4, lwd=2)
tabela_modelos_ETS_transf
# ETS com transformação
f_ets_transf <- function(y, h){
fit = ets(y, model="MMM", lambda = 0.712, damped = TRUE)
forecast(fit, h)
}
CV_ets_transf <- tsCV(y = dados, forecastfunction = f_ets_transf,
h = 5, initial = n-14)
MAE_ets_transf <-  CV_ets_transf %>% abs() %>% colMeans(na.rm=T)
MAE_ets_transf
# ETS com transformação
f_ets_transf <- function(y, h){
fit = ets(y, model="AAA", lambda = 0.712, damped = TRUE)
forecast(fit, h)
}
CV_ets_transf <- tsCV(y = dados, forecastfunction = f_ets_transf,
h = 5, initial = n-14)
MAE_ets_transf <-  CV_ets_transf %>% abs() %>% colMeans(na.rm=T)
MAE_ets_transf
# ETS com transformação
f_ets_transf <- function(y, h){
fit = ets(y, model="MMM", lambda = 0.712, damped = TRUE)
forecast(fit, h)
}
CV_ets_transf <- tsCV(y = dados, forecastfunction = f_ets_transf,
h = 5, initial = n-14)
V_ets_transf %>% abs() %>% colMeans(na.rm=T)
CV_ets_transf %>% abs() %>% colMeans(na.rm=T)
# Definindo as funções de previsão
# Arima
f_arima <- function(y, h){
fit = Arima(y, order=c(2,1,2), seasonal=c(0,1,2))
return(forecast(fit, h))
}
# Arima com transformação
f_arima_transf <- function(y, h){
fit = Arima(y, order=c(2,1,2), seasonal=c(0,1,2), lambda = 0.712)
forecast(fit, h)
}
# ETS
f_ets <- function(y, h){
fit = ets(y, model="AAA", damped = TRUE)
forecast(fit, h)
}
# ETS com transformação
f_ets_transf <- function(y, h){
fit = ets(y, model="AAA", lambda = 0.712, damped = TRUE)
forecast(fit, h)
}
# Tamanho da série
n <- length(dados)
# Cálculo dos erros de previsão para cada método
CV_arima <- tsCV(y = dados, forecastfunction = f_arima, h = 5, initial = n-14)
CV_arima_transf <- tsCV(y = dados, forecastfunction = f_arima_transf,
h = 5, initial = n-14)
tab_erros
CV_ets <- tsCV(y = dados, forecastfunction = f_ets, h = 5, initial = n-14)
CV_ets_transf <- tsCV(y = dados, forecastfunction = f_ets_transf,
h = 5, initial = n-14)
# Cálculo do erro absoluto médio (MAE) para cada horizonte de previsão
MAE_arima <- CV_arima %>% abs() %>% colMeans(na.rm=T)
MAE_arima_transf <-  CV_arima_transf %>% abs() %>% colMeans(na.rm=T)
MAE_ets <-  CV_ets %>% abs() %>% colMeans(na.rm=T)
MAE_ets_transf <-  CV_ets_transf %>% abs() %>% colMeans(na.rm=T)
tab <- cbind(as.numeric(MAE_arima), as.numeric(MAE_ets))
tab_transf <- cbind(MAE_arima_transf, MAE_ets_transf)
tab_erros <-  data.frame(MAE_arima, MAE_ets, MAE_arima_transf, MAE_ets_transf)
colnames(tab_erros) <- c('ARIMA', 'ETS',
'ARIMA Transformada', 'ETS Transformada')
knitr::kable(tab_erros)
tab_erros
plot.ts(tab_erros, plot.type='s',col=1:4,lwd=2,xlab="h",ylab="MAE")
legend(x=1,y=0.44, legend=c("ARIMA", "ETS", "ARIMA Transformada", "ETS Transformada"), col=1:4, lwd=2)
tab_erros
MAE_arima
tab_erros <-  tibble(MAE_arima, MAE_ets, MAE_arima_transf, MAE_ets_transf)
tab_erros
paste0("h=", c(1:5))
tab_erros <- tibble(
h = paste0("h=", c(1:5)),
MAE_arima = CV_arima %>% abs() %>% colMeans(na.rm=T),
MAE_arima_transf =  CV_arima_transf %>% abs() %>% colMeans(na.rm=T),
MAE_ets =  CV_ets %>% abs() %>% colMeans(na.rm=T),
MAE_ets_transf =  CV_ets_transf %>% abs() %>% colMeans(na.rm=T),
)
tab_erros
plot.ts(tab_erros, plot.type='s',col=2:5,lwd=2,xlab="h",ylab="MAE")
legend(x=1,y=0.44, legend=c("ARIMA", "ETS", "ARIMA Transformada", "ETS Transformada"), col=1:4, lwd=2)
tab_erros <- tibble(
h = paste0("h=", c(1:5)),
MAE_arima = CV_arima %>% abs() %>% colMeans(na.rm=T),
MAE_arima_transf =  CV_arima_transf %>% abs() %>% colMeans(na.rm=T),
MAE_ets =  CV_ets %>% abs() %>% colMeans(na.rm=T),
MAE_ets_transf =  CV_ets_transf %>% abs() %>% colMeans(na.rm=T),
)
plot.ts(tab_erros, plot.type='s',col=2:5,lwd=2,xlab="h",ylab="MAE")
legend(x=1,y=0.44, legend=c("ARIMA", "ETS", "ARIMA Transformada", "ETS Transformada"), col=1:4, lwd=2)
tab_erros
plot.ts(tab_erros, plot.type='s',col=2:5,lwd=2,xlab="h",ylab="MAE")
legend(x=1,y=0.44, legend=c("ARIMA", "ETS", "ARIMA Transformada", "ETS Transformada"), col=2:5, lwd=2)
plot.ts(tab_erros, plot.type='s',col=1:4,lwd=2,xlab="h",ylab="MAE")
legend(x=1,y=0.44, legend=c("ARIMA", "ETS", "ARIMA Transformada", "ETS Transformada"), col=1:4, lwd=2)
tab_erros
MAE_arima <- CV_arima %>% abs() %>% colMeans(na.rm=T)
MAE_arima_transf <-  CV_arima_transf %>% abs() %>% colMeans(na.rm=T)
MAE_ets <-  CV_ets %>% abs() %>% colMeans(na.rm=T)
MAE_ets_transf <-  CV_ets_transf %>% abs() %>% colMeans(na.rm=T)
tab <- cbind(as.numeric(MAE_arima), as.numeric(MAE_ets))
tab_transf <- cbind(MAE_arima_transf, MAE_ets_transf)
tab_erros <-  tibble(MAE_arima, MAE_ets, MAE_arima_transf, MAE_ets_transf)
# ARRUMAR
plot.ts(tab_erros, plot.type='s',col=1:4,lwd=2,xlab="h",ylab="MAE")
legend(x=1,y=0.44, legend=c("ARIMA", "ETS", "ARIMA Transformada", "ETS Transformada"), col=1:4, lwd=2)
tab_erros
tab_erros <- tibble(
h = paste0("h=", c(1:5)),
MAE_arima = CV_arima %>% abs() %>% colMeans(na.rm=T),
MAE_arima_transf =  CV_arima_transf %>% abs() %>% colMeans(na.rm=T),
MAE_ets =  CV_ets %>% abs() %>% colMeans(na.rm=T),
MAE_ets_transf =  CV_ets_transf %>% abs() %>% colMeans(na.rm=T),
)
tab_erros
# ARRUMAR
plot.ts(tab_erros, plot.type='s',col=2:5,lwd=2,xlab="h",ylab="MAE")
legend(x=1,y=0.44, legend=c("ARIMA", "ETS", "ARIMA Transformada", "ETS Transformada"), col=2:5, lwd=2)
# ARRUMAR
tab_erros %>%
select(-h) %>%
plot.ts(plot.type='s',col=1:4,lwd=2,xlab="h",ylab="MAE")
legend(x=1,y=0.44, legend=c("ARIMA", "ETS", "ARIMA Transformada", "ETS Transformada"), col=1:4, lwd=2)
